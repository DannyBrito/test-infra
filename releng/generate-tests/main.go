package main

import (
	"bytes"
	"embed"
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

//go:embed test.template.yml
var testTemplateFS embed.FS

const (
	GCSLOGPREFIX = "kubernetes-jenkins/logs/"
	COMMENT      = "AUTO-GENERATED by releng/generate-tests/main.go - DO NOT EDIT."
)

type options struct {
	yamlConfigPath     string
	testgridOutputPath string
	outputDir          string
}

func parseFlags() *options {
	opt := options{}
	flag.StringVar(&opt.outputDir, "output-dir", "config/jobs/kubernetes/generated/", "Write configmap here instead of stdout")
	flag.StringVar(&opt.testgridOutputPath, "testgrid-output-path", "config/testgrids/generated-test-config.yaml", "Name of resource")
	flag.StringVar(&opt.yamlConfigPath, "yaml-config-path", "", "Namespace for resource")
	flag.Parse()
	return &opt
}

func (opt *options) validateOptions() error {
	if opt.outputDir == "" {
		return errors.New("--output-dir must be specified")
	}
	if opt.testgridOutputPath == "" {
		return errors.New("--testgrid-output-path must be specified")
	}
	if opt.yamlConfigPath == "" {
		return errors.New("--yaml-config-path must be specified")
	}
	return nil
}
func main() {
	options := parseFlags()
	if err := options.validateOptions(); err != nil {
		log.Fatalln(err)
	}
	config := options.getYamlConfig()
	var jobNames []string
	for name := range config.Jobs {
		jobNames = append(jobNames, name)
	}
	slices.Sort(jobNames)
	outputConfig := OutputConfig{
		Periodics: []Periodic{},
	}
	testgridConfig := TestgridConfig{
		TestGroups: []TestGroup{},
	}
	for _, jobName := range jobNames {
		prow, testgrid := forEachJob(options.outputDir, jobName, config.Jobs[jobName], config)
		outputConfig.Periodics = append(outputConfig.Periodics, prow)
		if !testgrid.isEmpty() {
			testgridConfig.TestGroups = append(testgridConfig.TestGroups, testgrid)
		}
	}
	prowfilePath := filepath.Join(options.outputDir, "generated.yaml")
	// writeConfigToFile(prowfilePath, outputConfig, "")
	SaveConfigsToFile(outputConfig, prowfilePath)
	// writeConfigToFile(options.testgridOutputPath, testgridConfig, COMMENT)
}

func writeConfigToFile(outputFile string, config interface{}, comment string) {
	fmt.Printf("writing configuration to: %s\n", outputFile)

	data, err := yaml.Marshal(&config)
	if err != nil {
		fmt.Printf("error: %v\n", err)
		os.Exit(1)
	}

	if comment != "" {
		comment = "# " + comment + "\n\n"
		data = append([]byte(comment), data...)
	}

	err = os.WriteFile(outputFile, data, 0644)
	if err != nil {
		fmt.Printf("error: %v\n", err)
		os.Exit(1)
	}
}

func SaveConfigsToFile(data interface{}, outputFilePath string) {
	tmpt, err := template.ParseFS(testTemplateFS, "test.template.yml")
	if err != nil {
		log.Fatalf("fail to Parse Config Template: , %+v", err)
	}
	var buf bytes.Buffer
	err = tmpt.Execute(&buf, data)
	if err != nil {
		log.Fatalf("fail to render configs struct to yaml template, %+v", err)
	}
	log.Println("writing result output config file")
	if err := os.WriteFile(outputFilePath, buf.Bytes(), 0o600); err != nil {
		log.Fatalf("fail to write configs struct to yaml, %s", err)
	}
}

func forEachJob(outputDir string, jobName string, job Job, config Config) (Periodic, TestGroup) {
	// var jobConfig Job
	var prowConfig Periodic
	var testgridConfig TestGroup
	fields := strings.Split(jobName, "-")
	if len(fields) < 3 {
		log.Fatalln("Expected at least 3 fields in job name", jobName)
	}
	jobType := fields[2]
	switch jobType {
	case "e2e":
		e2eTest := newE2ETest(outputDir, jobName, job, config)
		_, prowConfig, testgridConfig = e2eTest.generate()
	case "e2enode":
		log.Println("nothing yet")
	default:
		log.Fatalf("Job %s has unexpected job type %s", jobName, jobType)
	}
	return prowConfig, testgridConfig
}

func newE2ETest(outputDir string, jobName string, job Job, config Config) E2ETest {
	envFilePath := filepath.Join(outputDir, jobName+".env")
	return E2ETest{
		EnvFilename:    envFilePath,
		JobName:        jobName,
		Job:            job,
		Common:         config.Common,
		CloudProviders: config.CloudProviders,
		Images:         config.Images,
		K8SVersions:    config.K8SVersions,
		TestSuites:     config.TestSuites,
	}
}
func (et *E2ETest) generate() (Job, Periodic, TestGroup) {
	log.Printf("generating e2e job: %s", et.JobName)
	fields := strings.Split(et.JobName, "-")
	if len(fields) != 7 {
		log.Fatalln("Expected 7 fields in job name", et.JobName)
	}
	image := et.Images[fields[4]]
	cloudProvider := et.CloudProviders[fields[3]]
	K8SVersion := et.K8SVersions[fields[5][3:]]
	testSuite := et.TestSuites[fields[6]]
	args := []string{}
	args = append(args, et.Common.Args...)
	args = append(args, cloudProvider.Args...)
	args = append(args, image.Args...)
	args = append(args, K8SVersion.Args...)
	args = append(args, testSuite.Args...)
	jobConfig := et.getJobDefinition(args)
	prowConfig := et.getProwConfig(testSuite)
	tgConfig := et.getTestGridConfig()
	tabName := fmt.Sprintf("%s-%s-%s-%s", fields[3], fields[4], fields[5], fields[6])
	if prowConfig.Annotations == nil {
		prowConfig.Annotations = map[string]string{}
	}
	prowConfig.Annotations["testgrid-tab-name"] = tabName
	dashboards := et.InitializeDashBoardsWithReleaseBlockingInfo(K8SVersion.Version)
	if image.TestgridPrefix != "" {
		dashboard := fmt.Sprintf("%s-%s-%s", image.TestgridPrefix, fields[4], fields[5])
		dashboards = append(dashboards, dashboard)
	}
	prowConfig.Annotations["testgrid-dashboards"] = strings.Join(dashboards, ", ")
	prowConfig.Annotations["testgrid-num-failures-to-alert"] = strconv.Itoa(et.Job.TestgridNumFailuresToAlert)
	return jobConfig, prowConfig, tgConfig
}

func (et *E2ETest) InitializeDashBoardsWithReleaseBlockingInfo(version string) []string {
	dashboards := []string{}
	dashboard := "sig-release-generated"
	if et.Job.ReleaseBlocking {
		dashboard = fmt.Sprintf("sig-release-%s-blocking", version)
	} else if et.Job.ReleaseInforming {
		dashboard = fmt.Sprintf("sig-release-%s-informing", version)
	}
	dashboards = append(dashboards, dashboard)
	return dashboards
}

func (et *E2ETest) getJobDefinition(args []string) Job {
	rSigOwner := et.Job.SigOwners
	if len(rSigOwner) == 0 {
		rSigOwner = []string{"UNKOWN"}
	}

	return Job{
		Scenario:  "kubernetes_e2e",
		Args:      args,
		SigOwners: rSigOwner,
	}
}

func (et *E2ETest) getTestGridConfig() TestGroup {
	return TestGroup{
		Name:      et.JobName,
		GCSPrefix: GCSLOGPREFIX + et.JobName,
		ColumnHeader: []ConfigurationValue{
			{
				ConfigurationValue: "node_os_image",
			},
			{
				ConfigurationValue: "master_os_image",
			},
			{
				ConfigurationValue: "Commit",
			},
			{
				ConfigurationValue: "infra-commit",
			},
		},
	}
}

func (et *E2ETest) getProwConfig(testSuite TestSuite) Periodic {
	prowConfig := Periodic{
		Name: et.JobName,
		Tags: []string{"generated"},
		Labels: map[string]string{
			"preset-service-account": "true",
			"preset-k8s-ssh":         "true",
		},
		Decorate: true,
		DecorationConfig: DecorationConfig{
			Timeout: "180m",
		},
		Spec: Spec{
			Containers: []Container{
				{
					Image: "gcr.io/k8s-staging-test-infra/kubekins-e2e:v20231206-f7b83ffbe6-master",
					Resources: Resources{
						Requests: ComputeResources{
							CPU:    "1000m",
							Memory: "3Gi",
						},
						Limits: ComputeResources{
							CPU:    "1000m",
							Memory: "3Gi",
						},
					},
					Args: []string{},
				},
			},
		},
	}
	if testSuite.Cluster != "" {
		prowConfig.Cluster = testSuite.Cluster
	} else if et.Job.Cluster != "" {
		prowConfig.Cluster = et.Job.Cluster
	}
	emptyResources := Resources{}
	if testSuite.Resources != emptyResources {
		prowConfig.Spec.Containers[0].Resources = testSuite.Resources
	} else if et.Job.Resources != emptyResources {
		prowConfig.Spec.Containers[0].Resources = et.Job.Resources
	}
	// Possible weird assumtion
	if et.Job.Interval != "" {
		prowConfig.Cron = ""
		prowConfig.Interval = et.Job.Interval
	} else if et.Job.Cron != "" {
		prowConfig.Interval = ""
		prowConfig.Cron = et.Job.Cron
	} else {
		log.Fatalln("No interval or cron definition found")
	}
	// Assumes that the value in --timeout is of minutes.
	var timeout int
	for _, arg := range testSuite.Args {
		if strings.HasPrefix(arg, "--timeout=") {
			value := arg[10:]
			timeout, _ = strconv.Atoi(value)
			break
		}
	}
	newTimeout := fmt.Sprintf("%vm", timeout+20)
	prowConfig.DecorationConfig.Timeout = newTimeout
	return prowConfig
}

type E2ETest struct {
	EnvFilename    string
	JobName        string
	Job            Job
	Common         Common
	CloudProviders map[string]CloudProvider
	Images         map[string]Image
	K8SVersions    map[string]K8SVersion
	TestSuites     map[string]TestSuite
}
type Job struct {
	Scenario                   string // `yaml:"interval"`
	Interval                   string `yaml:"interval"`
	Cron                       string
	SigOwners                  []string `yaml:"sigOwners"`
	ReleaseBlocking            bool     `yaml:"releaseBlocking"`
	ReleaseInforming           bool     `yaml:"releaseInforming"`
	Cluster                    string   `yaml:"cluster"`
	TestgridNumFailuresToAlert int      `yaml:"testgridNumFailuresToAlert"`
	Args                       []string `yaml:"args"`
	Resources                  Resources
}

// type JobDefinition struct {
// 	Scenario                   string   `yaml:"interval"`
// 	SigOwners                  []string `yaml:"sigOwners"`
// 	ReleaseBlocking            bool     `yaml:"releaseBlocking"`
// 	ReleaseInforming           bool     `yaml:"releaseInforming"`
// 	TestgridNumFailuresToAlert int      `yaml:"testgridNumFailuresToAlert"`
// 	Args                       []string `yaml:"args"`
// }

type K8SVersion struct {
	Args    []string `yaml:"args"`
	Version string   `yaml:"version"`
}
type Resources struct {
	Requests ComputeResources `yaml:"requests"`
	Limits   ComputeResources `yaml:"limits"`
}
type ComputeResources struct {
	CPU    string `yaml:"cpu"`
	Memory string `yaml:"memory"`
}

type TestSuite struct {
	Args      []string  `yaml:"args"`
	Resources Resources `yaml:"resources"`
	Cluster   string    `yaml:"cluster"`
}

type CloudProvider struct {
	Args []string
}

type Common struct {
	Args           []string
	TestgridPrefix string `yaml:"testgrid_prefix"`
}

type Image struct {
	Args           []string
	TestgridPrefix string `yaml:"testgrid_prefix"`
}

type Config struct {
	Jobs           map[string]Job           `yaml:"jobs"`
	CloudProviders map[string]CloudProvider `yaml:"cloudProviders"`
	Common         Common                   `yaml:"common"`
	Images         map[string]Image         `yaml:"images"`
	K8SVersions    map[string]K8SVersion    `yaml:"k8sVersions"`
	TestSuites     map[string]TestSuite     `yaml:"testSuites"`
}

func (opt *options) getYamlConfig() Config {
	yamlFile, err := os.ReadFile(opt.yamlConfigPath)
	if err != nil {
		log.Fatalln("error trying to read yaml config path file")
	}
	var config Config
	err = yaml.Unmarshal(yamlFile, &config)
	if err != nil {
		log.Fatalln("error trying to parse yaml config path file")
	}
	return config
}

//

type DecorationConfig struct {
	Timeout string `yaml:"timeout"`
}

type Container struct {
	Command   []string  `yaml:"command"`
	Args      []string  `yaml:"args"`
	Env       string    `yaml:"env"`
	Image     string    `yaml:"image"`
	Resources Resources `yaml:"resources"`
}

type Spec struct {
	Containers []Container `yaml:"containers"`
}

type Periodic struct {
	Tags             []string          `yaml:"tags"`
	Interval         string            `yaml:"interval"`
	Cron             string            `yaml:"cron"`
	Labels           map[string]string `yaml:"labels"`
	Decorate         bool              `yaml:"decorate"`
	DecorationConfig DecorationConfig  `yaml:"decoration_config"`
	Name             string            `yaml:"name"`
	Spec             Spec              `yaml:"spec"`
	Cluster          string            `yaml:"cluster"`
	Annotations      map[string]string `yaml:"annotations"`
}

type OutputConfig struct {
	Periodics []Periodic `yaml:"periodics"`
}

type TestgridConfig struct {
	TestGroups []TestGroup `json:"test_groups"`
}

// testgrid
type ConfigurationValue struct {
	ConfigurationValue string `json:"configuration_value"`
}

type TestGroup struct {
	Name         string               `json:"name"`
	GCSPrefix    string               `json:"gcs_prefix"`
	ColumnHeader []ConfigurationValue `json:"column_header"`
}

func (tg *TestGroup) isEmpty() bool {
	return tg.Name != "" || tg.GCSPrefix != "" || len(tg.ColumnHeader) != 0
}
